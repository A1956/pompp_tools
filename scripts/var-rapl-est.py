#!/usr/bin/env python

#
# The PomPP software including libraries and tools is developed by the
# PomPP (Power Managemant Framework for Post-Petascale Supoercomputers)
# research project supported by the JST, CREST research program.
# The copyrights for code used under license from other parties are
# included in the corresponding files.
# 
# Copyright (c) 2015, The PomPP research team.
#

import ric
import machine
import read

MAX_NITERA = 30

import sys

if __name__ == '__main__':
    debug=True
    #
    argc = len(sys.argv)
    if argc < 7:
        print "Usage: %s ubmt_table app_data" % sys.argv[0],
        print "pbs_nodefile nprocs module_pwr_cap conf-header"
        sys.exit(1)
    ubmt_table     = sys.argv[1]
    app_data       = sys.argv[2]
    pbs_nodefile   = sys.argv[3]
    nprocs         = int( sys.argv[4] )
    module_pwr_cap = float( sys.argv[5] )
    conf_header    = sys.argv[6]
    if debug:
        print "ubmt_table       = %s" % ubmt_table
        print "app_data         = %s" % app_data
        print "pbs_nodefile     = %s" % pbs_nodefile
        print "nprocs           = %d" % nprocs
        print "module power cap = %7.3f W" % module_pwr_cap
        print "config header    = %s" % conf_header


    npkgs          = machine.get_npkgs()
    (rmaxpkg, rmaxdrm, rminpkg, rmindrm) = read.read_ubmt_table( ubmt_table )
    #
    (secnames, app_maxpkg, app_maxdrm, app_minpkg, app_mindrm) = \
            read.read_app_data(app_data)
    nsec = len(secnames)
    if nsec < 1:
        print "ERROR: Illegal # of sections (%d)" % nsec
        sys.exit(1)

    app_est_maxpkg=[[0.0 for isec in range(nsec)] for ipkg in range(npkgs)]
    app_est_maxdrm=[[0.0 for isec in range(nsec)] for ipkg in range(npkgs)]
    app_est_minpkg=[[0.0 for isec in range(nsec)] for ipkg in range(npkgs)]
    app_est_mindrm=[[0.0 for isec in range(nsec)] for ipkg in range(npkgs)]
    for ipkg in range(npkgs):
        for isec in range(nsec):
            app_est_maxpkg[ipkg][isec] = rmaxpkg[ipkg]*app_maxpkg[isec]
            app_est_maxdrm[ipkg][isec] = rmaxdrm[ipkg]*app_maxdrm[isec]
            app_est_minpkg[ipkg][isec] = rminpkg[ipkg]*app_minpkg[isec]
            app_est_mindrm[ipkg][isec] = rmindrm[ipkg]*app_mindrm[isec]
    # 
    pkg_list = machine.needed_pkg_list( pbs_nodefile, nprocs )
    Ptot     = module_pwr_cap * nprocs
    alpha = [0.0 for isec in range(nsec)]
    for isec in range(nsec):
        Pmax=0.0
        Pmin=0.0
        for ipkg in range(npkgs):
            if pkg_list[ipkg] == 1:
                Pmax+=app_est_maxpkg[ipkg][isec]+app_est_maxdrm[ipkg][isec]
                Pmin+=app_est_minpkg[ipkg][isec]+app_est_mindrm[ipkg][isec]
        #
        alpha[isec] = (Ptot-Pmin)/(Pmax-Pmin)
        # debug
        #print "alpha[%d]= %10.6f" % (isec, alpha[isec])

    cpu_max = machine.get_tdp_pkg()
    cpu_min = machine.get_min_pkg()
    drm_max = machine.get_tdp_drm()
    drm_min = machine.get_min_drm()
    pwr_max = cpu_max + drm_max
    pwr_min = cpu_min + drm_min
    alpha0 = (module_pwr_cap - pwr_min)/(pwr_max - pwr_min)
    if alpha0 >= 1.0: alpha0 = 1.0
    cpu_default = alpha0 * (cpu_max-cpu_min) + cpu_min
    cpu_default = int( cpu_default * 8.0 ) * 0.125
    for ipkg in range(npkgs):
        if pkg_list[ipkg] == 0: continue
        confname="%s-%d.conf" % (conf_header, ipkg)
        try:
            f=open(confname, "w")
        except IOError:
            print "ERROR: Cannot open file %s for writting" % confname
            sys.exit(1)
        #
        f.write("# config automatically generated by var_rapl_est.py\n")
        f.write("#-k cpu\n")
        f.write("#-d %.3f\n" % cpu_default )
        for isec in range(nsec):
            cpu=alpha[isec]*\
                    (app_est_maxpkg[ipkg][isec]-app_est_minpkg[ipkg][isec])\
                    + app_est_minpkg[ipkg][isec]
            cpu = (int(cpu*8.0))*0.125
            if cpu > 130.0 : cpu=130.0
            f.write("#-s %s %7.3f\n" % (secnames[isec], cpu) )
            # debug
            if debug: print " %4d %8s %7.3f" % (ipkg, secnames[isec], cpu)
        f.close()
